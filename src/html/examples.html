<!DOCTYPE html>
<html>
    <head>
        <title>Examples</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <div>
            <h1>How to write Loop Structures in WALL</h1>
            <p>
                Just like in High-Level Languages, WALL and any other Assemblers
                are capable of looping over a section of code until a condition is
                met.<br>
                The following two examples of how a user would write a While loop 
                and a do While loop in WALL.
            </p>
            <br>
            <pre>
                # Sum of the first 10 numbers<br>
                # R0 is 11 since we terminate on equality.<br>
                # If R0 was 10, we'd get the sum of the first 9 numbers.<br>
                        org 0x00<br>
                main:   load R0,11          # Termination Condition<br>
                        load R1,1           # Constant 1<br>
                        xor  R2,R2,R2       # Load R2 with 0<br>
                        xor  RA,RA,RA       # Load RA with 0<br>
                        jmp  while<br>
                <br>
                while:  jmpeq R2=R0,done    # while R2 != 0<br>
                        add   RA,RA,R2      #   Sum = Sum + number<br>
                        add   R2,R2,R1      #   number = number + 1<br>
                        jmp   while<br>
                <br>
                done:   halt<br>
                <br>
                <samp>
                    Result of the Above Program: R10: 55
                </samp>
            </pre>
            <pre>
                # Sum of the first 10 numbers<br>
                # R0 is 11 since we terminate when R2 is greater than<br>
                # or equal to R0.<br>
                # If R0 was 10, we'd get the sum of the first 9 numbers.<br>
                            org   0x00<br>
                main:       load  R0,11             # Termination Condition<br>
                            load  R1,1              # Constant 1<br>
                            xor   R2,R2,R2          # Load R2 with 0<br>
                            xor   RA,RA,RA          # Load RA with 0<br>
                            jmp   doWhile<br>
                <br>
                doWhile:    add   RA,RA,R2          # Do: Sum = Sum + number<br>
                            add   R2,R2,R1          #     number = number + 1<br>
                            jmplt R2&lt;R0,doWhile     # while R2 &lt; R0<br>
                <br>
                done:       halt<br>
                <br>
                <samp>
                    Result of the Above Program: R10: 55
                </samp>
            </pre>
            <h1>How to Iterate through an Array</h1>
            <p>
                In High-Level Languages, to get to each value in an array you need
                to iterate through each index of the array. WALL is no different.<br>
                There are two ways to create arrays in WALL; with the DB and the BSS
                pseudo-ops.<br>
                DB  - will "initialize" an array with values.<br>
                BSS - will "reserve" X amount of memory (no need to "initialize").<br>
                Note: DB is special, in that it allows you to create a String of
                characters using quotation marks ("") or apostrophes (''). What DB
                does in these cases, is assign each character to an address (sequentially).
                So, that means each character is at a different "index" of the array.<br>
                <br>
                There are two things to note in the Code below.
            </p>
            <ol>
                <li>
                    The output of both loops is the same, since they both look for
                    the same terminating condition (a null character). This is a
                    common way to end a string (all Strings in C are null character
                    terminated).
                </li>
                <li>
                    To iterate through an array in WALL, a user needs to begin at
                    the first address of the array (usually pointed to by a label,
                    in this case, the label "Head"), and then increment their way
                    through the addresses of the array (like they would through the
                    indices of an array in a High-Level Language).
                </li>
            </ol>
            <pre>
                # Iterate through a String and display it to<br>
                # the Display Console.<br>
                <br>
                # Data Section<br>
                        org   0x60<br>
                Head:   db    "The Cake is a lie",0 # 0 = null termination character<br>
                <br>
                        org   0x00<br>
                        sip   main<br>
                <br>
                main:   load  R0,0                  # check for null term. char.<br>
                        load  R1,1                  # constant 1<br>
                        load  R2,Head               # pointer to the array of chars.<br>
                        iload R3,[R2]               # get the value at the pointer<br>
                        jmp   while<br>
                <br>
                while:  jmpeq R3=R0,done            # while R3 != R0, iterate<br>
                        move  RF,R3                 # display character<br>
                        add   R2,R2,R1              # increment pointer<br>
                        iload R3,[R2]               # get the value at the pointer<br>
                        jmp   while                 # repeat<br>
                <br>
                done:   halt<br>
                <br>
                <samp>
                    Results will display in the Display Console: The Cake is a Lie
                </samp>
            </pre>
            <pre>
                # Iterate through a String and display it to<br>
                # the Display Console.<br>
                <br>
                # Data Section<br>
                        org   0x60<br>
                Head:   db    "The Cake is a lie",0 # 0 = null termination character<br>
                <br>
                        org   0x00<br>
                        sip   main<br>
                <br>
                main:   load  R0,0                  # check for null term. char.<br>
                        load  R1,1                  # constant 1<br>
                        load  R2,Head               # pointer to the array of chars.<br>
                        iload R3,[R2]               # get the value at the pointer<br>
                        jmp   doWhile<br>
                <br>
                doWhile:    move  RF,R3             # do: display character<br>
                            add   R2,R2,R1          #     increment pointer<br>
                            iload R3,[R2]           #     get the value at the pointer<br>
                            jmpeq R3=R0,done        # while R3 != R0, iterate<br>
                            jmp   doWhile           # repeat<br>
                <br>
                done:       halt<br>
                <br>
                <samp>
                    Results will display in the Display Console: The Cake is a Lie
                </samp>
            </pre>
            <h1>How to Compare Less than with Signed Numbers</h1>
            <p>
                The JMPLT Operation treats the arguments in R0 and RH as unsigned
                values. This can be really useful, it can also be restraining. Luckily,
                through a simple trick, we can get the functionality of Signed Comparison
                with JMPLT.<br>
                All you have to do is swap the values in the argument registers.
                This gets you the functionality of a "greater than" comparison. So,
                since negative numbers will all have their High-Order bit on, they
                are naturally "larger" (in their positive sense, -1 is 255 unsigned).<br>
                The program below displays this functionality. First it compares
                -1 and 1, which the instruction sees as 255 &lt; 1 (obviously, 1 is
                smaller). The second comparison is 1 to -1, which the instruction
                sees as 1 &lt; 255 (obviously true).<br>
                With just a bit of logical maneuvering, you can now check signed
                numbers, or even just do a "greater than" comparison.
            </p>
            <br>
            <pre>
                # Does a Less Than comparison with JMPLT and then does a Greater<br>
                # Than comparison with JMPLT (just by switching the arguments).<br>
                # The Smaller of the two values will be stored into their respective<br>
                # memory addresses at location 0x70 and 0x71.<br>
                <br>
                # Data Section<br>
                            org   0x60<br>
                Num:        db    0x01      # 1<br>
                Neg:        db    0xFF      # -1<br>
                            org   0x70<br>
                SmallerLT:  bss   1         # posComp Result<br>
                SmallerGT:  bss   1         # negComp Result<br>
                <br>
                            # Both the labels "main" and "posComp" point to the<br>
                            # same memory address.<br>
                main:<br>
                posComp:    load  R0,[Num]<br>
                            load  R1,1<br>
                            load  R2,[Neg]<br>
                            jmplt R2&lt;R0,lessThan        # if -1 &lt; 1, store -1<br>
                            store [SmallerLT],R0        # else, store 1<br>
                            jmp   negComp               #       -1 is greater than 1<br>
                <br>
                lessThan:   store [SmallerLT],R2        # Will never reach here<br>
                <br>
                negComp:    load  R0,[Neg]<br>
                            load  R2,[Num]<br>
                            jmplt R2&lt;R0,grtrThan        # if 1 &lt; -1, store -1<br>
                            store [SmallerGT],R2        # else, store 1 - Will never reach here<br>
                <br>
                grtrThan:   store [SmallerGT],R0        # -1 is less than 1<br>
                <br>
                done:       halt<br>
            </pre>
            <h1>Learning Stack Discipline</h1>
            <p>
                
            </p>
            <pre>
                
            </pre>
        </div>
    </body>
</html>
