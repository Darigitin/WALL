<!DOCTYPE html>
<!--
Program: languageReference

Purpose: 

@author: jl948836

date/ver: 03/26/16 1.0.0
-->
<html>
    <head>
        <title>WALL (WTAMU AssembLy Language) Language Reference</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            table, th, td {
                 border: 1px solid black;
            }
            operations {
                column-width: 25%;
            }
            op-codes {
                column-width: 10%;
            }
            examples {
                column-width: 25%;
            }
            descriptions {
                column-width: 45%;
            }
        </style>
    </head>
    <body>
        <div>
            <h1>WALL (WTAMU AssembLy Language) Language Reference</h1>
            <h2>Operations</h2>
            <table>
                <thead>
                    <tr>
                        <th id="operations">
                            Operation
                        </th>
                        <th id="op-codes">
                            Op-Code
                        </th>
                        <th id="examples">
                            Example
                        </th>
                        <th id="descriptions">
                            Description
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            ADD RL,RM,RN
                        </td>
                        <td>
                            5L MN
                        </td>
                        <td>
                            ADD R0,R1,R2<br>
                            Assembled => 50 12<br> 
                        </td>
                        <td>
                            Adds the value in Registers M and N, assuming unsigned
                            numbers, and stores the result in Register L.<br>
                            reg[L] := reg[M] + reg[N]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            AND RL,RM,RN
                        </td>
                        <td>
                            8L MN
                        </td>
                        <td>
                            AND R1,R2,R3<br>
                            Assembled => 8123<br>
                        </td>
                        <td>
                            Bit-wise AND the bit patterns in Registers M and N and
                            store the result in Register L.<br>
                            reg[L] := reg[M] AND reg[N]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            CALL XY
                        </td>
                        <td>
                            60 XY
                        </td>
                        <td>
                            CALL label<br>
                            org 0x30<br>
                            label: bss 0x01<br>
                            Assembled => 60 30<br>
                        </td>
                        <td>
                            <ol>
                                <li>Pushes the Instruction Pointer onto the stack.</li>
                                <li>Places address indicated by argument into the IP.</li>
                            </ol>
                            The argument can be a Label, EQU label, int, or hex value.<br>
                            Note: The push causes the Stack Pointer to be decremented
                            by 1.<br>
                            PUSH reg[IP]<br>
                            reg[IP] := label (the address of the label)<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            HALT
                        </td>
                        <td>
                            C0 00
                        </td>
                        <td>
                            HALT<br>
                            Assembled => C0 00<br>
                        </td>
                        <td>
                            Halts program execution. The last byte of the instruction
                            is ignored.<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            ILOAD RN,[RM]
                        </td>
                        <td>
                            D0 NM
                        </td>
                        <td>
                            ILOAD R1,[R2]<br>
                            Assembled => D0 12<br>
                        </td>
                        <td>
                            Indirect Load - loads Register N with the value from memory
                            pointed to by the value in Register M.<br>
                            reg[N] := memory[reg[M]]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            ISTORE [RM],RN
                        </td>
                        <td>
                            D1 NM
                        </td>
                        <td>
                            ISTORE [RB],RA<br>
                            Assembled => D1 AB<br>
                        </td>
                        <td>
                            Indirect Store - stores the value in Register N into
                            the memory cell pointed to by Register M.<br>
                            memory[reg[M]] := reg[N]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            JMP 0xXY
                        </td>
                        <td>
                            B0 XY
                        </td>
                        <td>
                            JMP label<br>
                            org 0x30<br>
                            label:<br>
                            Assembled => B0 30<br>
                        </td>
                        <td>
                            Unconditional Jump - loads the Instruction Pointer with the value
                            indicated by the argument (usually a label), unconditionally.<br>
                            reg[IP] := XY<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            JMPEQ RN=R0,XY
                        </td>
                        <td>
                            BN XY
                        </td>
                        <td>
                            JMPEQ R1=R0,label<br>
                            org 0x32<br>
                            label:<br>
                            Assembled => B1 32<br>
                        </td>
                        <td>
                            (Conditional Branch)<br>
                            Jump Equal To - loads the Instruction Pointer with the value
                            indicated by the XY portion of the argument (usually a label
                            is used instead of an Absolute Address), if the value in
                            Register N is equal to the value in Register 0; otherwise,
                            execution will continue to the next sequential instruction
                            in memory.<br>
                            if (RN=R0)<br>
                            &nbsp;reg[IP] := XY<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            JMPLT RN&lt;R0,XY
                        </td>
                        <td>
                            FN XY
                        </td>
                        <td>
                            JMPLT R1&lt;R0,label<br>
                            org 0x32<br>
                            label:<br>
                            Assembled => F1 32<br>
                        </td>
                        <td>
                            (Conditional Branch)<br>
                            Jump Less Than - loads the Instruction Pointer with the value
                            indicated by the XY portion of the argument (usually a label
                            is used instead of an Absolute Address), if the value in
                            Register N is less than the value in Register 0; otherwise,
                            execution will continue to the next sequential instruction in
                            memory.<br>
                            if (RN&lt;R0)<br>
                            &nbsp;reg[IP] := XY<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            LOAD RN,XY
                        </td>
                        <td>
                            1N XY
                        </td>
                        <td>
                            LOAD R3,0x01<br>
                            Assembled => 13 01<br>
                        </td>
                        <td>
                            Immediate Load - loads Register N with the value XY.<br>
                            Note: A label can be used in place of an XY value.<br>
                            reg[N] := XY<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            LOAD RN,[XY]
                        </td>
                        <td>
                            2N XY
                        </td>
                        <td>
                            label: db 1<br>
                            LOAD R3,[label]<br>
                            Assembled => 23 01<br>
                        </td>
                        <td>
                            Direct Load - loads Register N with the value at address
                            XY in memory.<br>
                            Note: A label can be used in place of an Absolute Address.<br>
                            reg[N] := memory[XY]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            MOVE RN,RM
                        </td>
                        <td>
                            40 MN
                        </td>
                        <td>
                            MOVE R1,R2<br>
                            Assembled => 40 21<br>
                        </td>
                        <td>
                            Copies the value in Register M to Register N.<br>
                            reg[N] := reg[M]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            OR RL,RM,RN
                        </td>
                        <td>
                            7L MN
                        </td>
                        <td>
                            OR R1,R2,R3<br>
                            Assembled => 71 23<br>
                        </td>
                        <td>
                            Bit-wise OR the bit patterns in Registers M and N, and
                            store the result in Register L.<br>
                            reg[L] := reg[M] OR reg[N]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            POP RM
                        </td>
                        <td>
                            65 M0
                        </td>
                        <td>
                            POP RBP
                            Assembled => 65 D0
                        </td>
                        <td>
                            <ol>
                                <li>
                                    Get the value pointed to by the Stack Pointer, and
                                    place it into Register M.<br>
                                </li>
                                <li>Increment the Stack Pointer by 1.</li>
                            </ol>
                            Note: Last nibble is ignored.<br>
                            reg[M] := memory[reg[SP]]<br>
                            reg[SP] := reg[SP] + 1<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            PUSH RM
                        </td>
                        <td>
                            64 M0
                        </td>
                        <td>
                            PUSH R2
                            Assembled => 64 20
                        </td>
                        <td>
                            <ol>
                                <li>Decrement the Stack Pointer by 1.</li>
                                <li>
                                    Place value in Register M into the memory
                                    cell pointed to by the Stack Pointer.<br>
                                </li>
                            </ol>
                            Note: Last nibble is ignored.<br>
                            reg[SP] := reg[SP] - 1<br>
                            memory[reg[SP]] := reg[M]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            RET XY
                        </td>
                        <td>
                            61 XY
                        </td>
                        <td>
                            RET<br>
                            Assembled => 61 01<br>
                        </td>
                        <td>
                            Returns from current stack frame. Takes an optional argument.
                            The argument is a number (in either hex or dec.), and is added to the
                            Stack Pointer (RE/RSP) at the end of execution (in addition to the
                            default 1 passed to the instruction). If no argument is passed
                            a default of 1 is passed to the instruction (In this case, opcode is 61 01).<br>
                            Note: By convention, Register A contains the return value.<br>
                            <ol>
                                <li>
                                    Gets Return Address pointed to by the Stack Pointer and
                                    loads it into the IP.
                                </li>
                                <li>Increment Stack pointer by 1 + XY</li>
                            </ol>
                            reg[IP] := memory[reg[SP]]<br>
                            reg[SP] := reg[SP] + 1 + XY<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            RLOAD RN,H[RM]
                        </td>
                        <td>
                            Immediate load - 2N FH<br>
                            Relative load  - D2 NM<br>
                        </td>
                        <td>
                            RLOAD R1,0x04[R2]<br>
                            Assembled => 21 F4 D2 12<br>
                        </td>
                        <td>
                            Relative Load - loads Register N with the value from
                            memory pointed to by Register M, plus the offset H.
                            Offset Range: -8 &lt;= H &lt;= 7<br>
                            Note: This operation assembles into two op-codes. The
                            first is an Immediate Load, to store the offset (the
                            third nibble "F" is a flag for the RLOAD Instruction),
                            and the second is the relative load itself.<br>
                            reg[N] := memory[reg[M] + H]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            ROR RN,XY
                        </td>
                        <td>
                            A0 NX
                        </td>
                        <td>
                            ROR R1,4<br>
                            Assembled => A0 14<br>
                        </td>
                        <td>
                            Rotate Right - Rotates the bit pattern in Register N one bit to the
                            right X times.<br>
                            Note: This is a circular shift, so the bit that is
                            rotated out of the low-order end is appended to the start
                            of the high-order end.<br>
                            reg[N] := Reg[N] ROR X<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            ROL RN,X
                        </td>
                        <td>
                            A1 NX
                        </td>
                        <td>
                            ROL R1,3
                            Assembled => A1 13
                        </td>
                        <td>
                            Rotate Left - Rotates the bit pattern in Register N
                            one bit to the right X times.<br>
                            Note: This is a circular shift; so the bit that is
                            rotated out of the high-order end is appended to the
                            end of the low-order end.<br>
                            reg[N] := Reg[N] ROL X<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            RSTORE H[RM],RN
                        </td>
                        <td>
                            EH NM
                        </td>
                        <td>
                            RSTORE 0x04[R2],R1<br>
                            Assembled: E4 12<br>
                        </td>
                        <td>
                            Relative Store - stores the value in Register N into
                            the memory cell pointed to by the address in Register M,
                            plus Offset H.<br>
                            Offset Range: -8 &lt;= H &lt;= 7<br>
                            memory[reg[M] + H] := reg[N]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            SCALL XY
                        </td>
                        <td>
                            62 XY
                        </td>
                        <td>
                            SCALL label<br>
                            org 0x30<br>
                            label: bss 0x01<br>
                            Assembled => 62 30<br>
                        </td>
                        <td>
                            <ol>
                                <li>Pushes the Instruction Pointer onto the Stack.</li>
                                <li>Places address indicated by argument into the IP.</li>
                                <li>Pushes the Base Pointer onto the Stack.</li>
                                <li>Copies the value in RE(SP) into RD(BP).</li>
                            </ol>
                            The argument can be a Label, EQU label, int, or hex value.<br>
                            Note: Pushes twice, once for the Return Address and once
                            for the Base Pointer.<br>
                            PUSH reg[IP]<br>
                            reg[IP] := XY (typically a Label)<br>
                            PUSH reg[D(BP)]<br>
                            reg[BP] := reg[SP]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            SRA RN,X
                        </td>
                        <td>
                            A2 NX
                        </td>
                        <td>
                            SRA R1,6<br>
                            Assembled => A2 16
                        </td>
                        <td>
                            Shift Right (Arithmetic) - Shifts the value in Register
                            N to the right X number of times. After each shift the
                            vacant High-Order bit is filled with the sign bit (1 if
                            negative, 0 if positive).<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            SRL RN,X
                        </td>
                        <td>
                            A3 NX
                        </td>
                        <td>
                            SRL R1,8<br>
                            Assembled => A3 18
                        </td>
                        <td>
                            Shift Right (Logical) - Shifts the value in Register
                            N to the right X number of times. After each shift, the
                            vacant High-Order bit is filled in with a 0.<br>
                            reg[N] := reg[N] &gt;&gt; X<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            SL RN,X
                        </td>
                        <td>
                            A4 NX
                        </td>
                        <td>
                            SL R1,0<br>
                            A4 10
                        </td>
                        <td>
                            Shift Left - Shifts the value in Register N to the
                            left X number of times. After each shift, the vacant
                            Low-Order bit is filled in with a 0.<br>
                            reg[N] := reg[N] &lt;&lt; X<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            STORE [XY],RN
                        </td>
                        <td>
                            3N XY
                        </td>
                        <td>
                            Store [0x30],R1<br>
                            Assembled => 31 30<br>
                        </td>
                        <td>
                            Direct Store - stores the value in Register N into the
                            memory cell at address XY.<br>
                            Note: A label can be used in place of an Absolute Address (XY)<br>
                            memory[XY] := reg[N]<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            XOR RL,RM,RN
                        </td>
                        <td>
                            9L MN
                        </td>
                        <td>
                            XOR R3,R2,R1<br>
                            Assembled => 93 21<br>
                        </td>
                        <td>
                            Bit-wise EXCLUSIVE OR the bit patterns in Registers M and
                            N and store the result in Register L.<br>
                            reg[L] := reg[M] XOR reg[N]<br>
                        </td>
                    </tr>
                </tbody>
            </table>
            <h2>Pseudo-Ops</h2>
            <p>
                Pseudo-Ops are similar to Operations, except that they do not compile
                as code directly into memory. Instead, they act as a kind of marker
                that tell the Assembler how to handle some kinds of associations and data.<br>
            </p>
            <table>
                <thead>
                    <tr>
                        <td>
                            Pseudo-Op
                        </td>
                        <td>
                            Example
                        </td>
                        <td>
                            Description
                        </td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            BSS
                        </td>
                        <td>
                            label: bss 0xXY
                        </td>
                        <td>
                            Block Storage Start - allocates a block of memory the
                            size of XY (in hex). The block is referenced by the label
                            (which is required by the syntax of the instruction).<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            DB
                        </td>
                        <td>
                            label: db 0xXY[,0xXY]<br>
                            label: DB XY[,XY]<br>
                            label: db "String"<br>
                                   dB label<br>
                        </td>
                        <td>
                            Data Byte - places the value(s) in memory, starting at the
                            current location in memory (indicated by the preceding ORG
                            Pseudo-Op, plus some offset; calculated by the Instructions
                            and Pseudo-Ops between itself and the ORG).<br>
                            Note: Labels are optional, and a db located below a label with
                            no instruction following it, will be associated with that<br>
                            label.<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            EQU
                        </td>
                        <td>
                            label: equ newLabel<br>
                            label: equ 0xXY<br>
                            label: EQU XY<br>
                            label: eQU RH<br>
                        </td>
                        <td>
                            Equivalent - creates a label to reference hex values, int
                            values, other labels, and registers.<br>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            ORG
                        </td>
                        <td>
                            org 0xXY<br>
                            org label<br>
                        </td>
                        <td>
                            Origin - places the next instruction or data byte at the
                            memory address XY. This allows a program or data to be
                            placed at arbitrary places in memory.<br>
                            Note: the argument must be Hex or a Label.<br>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </body>
</html>
