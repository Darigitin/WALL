


*************************** WALL-Listing ***********************
Created date: 05/06/2016 07:11:39 PM

Location    Object Code       Line   Source Statement
                                 1   sip     main
                                 2   
                                 3   LineFeed:       EQU     0xA
                                 4                   org     0x00
                                 5   main:          
00          27 01                6                    load    R7,1
02          28 00                7                    load    R8,  0         # i
04          26 AC                8                    load    R6,Numbers
06          10 B7                9                    load    R0,[Length]
                                10   mainLoop:
08          B8 1C               11                    jmpEQ   R8=R0,endMain
0A          D0 96               12                    iload   R9,[R6]         # Numbers[i]
0C          64 00               13                    push    R0
0E          64 90               14                    push    R9
10          60 1E               15                    call    printByte
12          65 00               16                    pop     R0
14          2F 0A               17                    load    RF,LineFeed
16          56 67               18                    add     R6,R6,R7
18          58 87               19                    add     R8,R8,R7
1A          B0 08               20                    jmp     mainLoop
                                21   endMain:
1C          C0 00               22                    halt
                                23                 
                                24                 
                                25   printByte:
                                26   pBaByte:        EQU     RA
1E          64 D0               27                    push    RBP
20          D2 DE               28                    move    RBP,RSP
                                29                  
22          42 AD               30                    rload   pBaByte,2[RBP]
24          D2 2A               31                    move    R2,pBaByte
26          A0 27               32                    ror     R2,7
28          21 01               33                    load    R1,1
2A          82 21               34                    and     R2,R2,R1
2C          90 00               35                    xor     R0,R0,R0
2E          B2 3C               36                    jmpEQ   R2=R0,pBNonNegative
30          2F 2D               37                    load    RF,0x2D         # ASCII -
32          D2 2A               38                    move    R2,pBaByte
34          20 FF               39                    load    R0,0xFF
36          92 20               40                    xor     R2,R2,R0
38          52 21               41                    add     R2,R2,R1
3A          D2 A2               42                    move    pBaByte,R2
3C          64 A0               43    pBNonNegative:  push    pBaByte
3E          60 80               44                    call    pBR
                                45                                
40          D2 ED               46                    move    RSP,RBP
42          65 D0               47                    pop     RBP
44          61 02               48                    ret     1
                                49                  
                                50   
                                51   div10:
                                52   div10q:         EQU     RA
                                53   div10aNum:      EQU     RB
46          64 D0               54                    push    RBP
48          D2 DE               55                    move    RBP,RSP
                                56                  
4A          42 AD               57                    rload   RA,2[RBP]
4C          D2 1A               58                    move    r1,RA
4E          D2 2A               59                    move    r2,RA
50          A3 11               60                    srl     R1,1
52          A3 22               61                    srl     R2,2
54          5A 12               62                    add     RA,R1,R2
56          A3 A3               63                    srl     RA,3            # RA now may hold quotient
                                64   
58          D2 1A               65                    move    R1,RA
5A          A4 12               66                    sl      R1,2
5C          51 1A               67                    add     R1,R1,RA
5E          A4 11               68                    sl      R1,1            # quotient * 10
60          22 FF               69                    load    R2,0xFF
62          91 12               70                    xor     R1,R1,R2        # toggle all bits
64          22 01               71                    load    R2,1
66          51 12               72                    add     R1,R1,R2
68          42 BD               73                    rload   RB,2[RBP]       # argument
6A          5B B1               74                    add     RB,RB,R1        # argument - (quotient * 10) == remainder
6C          20 0A               75                    load    R0,10
6E          BB 7A               76                    jmpEQ   RB=R0,div10return
70          FB 7A               77                    jmpLT   RB<R0,div10return
72          21 01               78                    load    R1,1
74          5A A1               79                    add     RA,RA,R1
76          21 F6               80                    load    R1,-10
78          5B B1               81                    add     RB,RB,R1
                                82   div10return:   
                                83                  
7A          D2 ED               84                    move    RSP,RBP
7C          65 D0               85                    pop     RBP
7E          61 02               86                    ret     1
                                87                  
                                88                  
                                89   #def pBR( aNum ):
                                90   #    (quotient,remainder) = div10a( aNum )
                                91   #    if 10 <= aNum:
                                92   #        pBR( quotient )
                                93   
                                94   #    digitChar = chr( remainder | 0x30 )
                                95   #    print(digitChar, end="", flush=True)
                                96   # end pBR  
                                97   
                                98                   org    0x80
                                99   pBR:
                               100   pBRquotient:    EQU     RA
                               101   pBRremainder:   EQU     RB
                               102   pBRaNum:        EQU     R3
80          64 D0              103                    push    RBP
82          D2 DE              104                    move    RBP,RSP
                               105                                
84          42 3D              106                    rload   pBRaNum,2[RBP]
                               107                   # check for 0x80 which could be passed in
86          20 80              108                    load    R0,0x80
88          B3 8C              109                    jmpEQ   pBRaNum=R0,pBRnegative
8A          B0 92              110                    jmp     pBRnormal
                               111   pBRnegative:
8C          2A 0C              112                    load    RA,12       # 128/10
8E          2B 08              113                    load    RB,8        # 128 % 10
90          B0 9A              114                    jmp     pBRcall
                               115   
92          64 30              116    pBRnormal:      push    pBRaNum
94          60 46              117                    call    div10
                               118                   # test for recursion
96          20 0A              119                    load    R0,10
98          F3 A2              120                    jmpLT   pBRaNum<R0,pBRdisplay
9A          64 B0              121    pBRcall:        push    pBRremainder    #save it so we have it when we return
9C          64 A0              122                    push    pBRquotient
9E          60 80              123                    call    pBR
A0          65 B0              124                    pop     pBRremainder    #recover remainder
A2          22 30              125    pBRdisplay:     load    R2,0x30
A4          7F B2              126                    or      RF,pBRremainder,R2
                               127                  
                               128   pBRreturn:                    
A6          D2 ED              129                    move    RSP,RBP
A8          65 D0              130                    pop     RBP
AA          61 02              131                    ret     1
AC          80 C1 E1 F1 F8     132    Numbers:        db      -128, -63, -31,-15, -8, 0, 3, 63, 64, 65, 0x7F
            00 03 3F 40 41            
            7F                        
B7          0B                 133    Length:         db      11


***************** WALL Cross-Reference Listing *******************
Created date: 05/06/2016 07:11:39 PM


         Cross-Reference Listing Description
Labels: The label name that appears in the source program.
Mem_Loc: Memory location of a label in the memory. If the value
         starts with 'R', it represents a register. If the value
         starts with a 'label', it means labels mapped to labels.
Def_Line: Defined line number of a label in the source code.
Ref_line: Referenced line number(s) of a label in the source code.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Labels           Mem_Loc     Def_Line     Ref_line
LineFeed            0A           3        17             
main                00           5                       
mainLoop            08          10        20             
endMain             1C          21        11             
printByte           1E          25        15             
pBaByte             RA          26        30  31  38  42  43  
pBNonNegative       3C          43        36             
div10               46          51        117            
div10q              RA          52                       
div10aNum           RB          53                       
div10return         7A          82        76  77         
pBR                 80          99        44  123        
pBRquotient         RA         100        122            
pBRremainder        RB         101        121  124  126  
pBRaNum             R3         102        106  116       
pBRnegative         8C         111        109            
pBRnormal           92         116        110            
pBRcall             9A         121        114            
pBRdisplay          A2         125        120            
pBRreturn           A6         128                       
Numbers             AC         132        8              
Length              B7         133        9              
