*************************** WALL-Listing ***********************
Created date: 05/05/2016 06:22:49 PM


Location    Object Code       Line   Source Statement
                                 1   sip     main
                                 2   
                                 3   LineFeed:       EQU     0xA
                                 4                   org     0x00
                                 5   main:          
00          27 01                6                    load    R7,1
02          28 00                7                    load    R8,  0         # i
04          26 DC                8                    load    R6,Numbers
06          10 E7                9                    load    R0,[Length]
                                10   mainLoop:
08          B8 1C               11                    jmpEQ   R8=R0,endMain
0A          D0 96               12                    iload   R9,[R6]         # Numbers[i]
0C          64 00               13                    push    R0
0E          64 90               14                    push    R9
10          60 1E               15                    call    printByte
12          65 00               16                    pop     R0
14          2F 0A               17                    load    RF,LineFeed
16          56 67               18                    add     R6,R6,R7
18          58 87               19                    add     R8,R8,R7
1A          B0 08               20                    jmp     mainLoop
                                21   endMain:
1C          C0 00               22                    halt
                                23                 
                                24                 
                                25   printByte:
                                26   pBaByte:        EQU     RA
1E          64 D0               27                    push    RBP
20          D2 DE               28                    move    RBP,RSP
                                29                  
22          42 AD               30                    rload   pBaByte,2[RBP]
24          D2 2A               31                    move    R2,pBaByte
26          A0 27               32                    ror     R2,7
28          21 01               33                    load    R1,1
2A          82 21               34                    and     R2,R2,R1
2C          90 00               35                    xor     R0,R0,R0
2E          B2 3C               36                    jmpEQ   R2=R0,pBNonNegative
30          2F 2D               37                    load    RF,0x2D         # ASCII -
32          D2 2A               38                    move    R2,pBaByte
34          20 FF               39                    load    R0,0xFF
36          92 20               40                    xor     R2,R2,R0
38          52 21               41                    add     R2,R2,R1
3A          D2 A2               42                    move    pBaByte,R2
3C          64 A0               43    pBNonNegative:  push    pBaByte
3E          60 B0               44                    call    pBR
                                45                                
40          D2 ED               46                    move    RSP,RBP
42          65 D0               47                    pop     RBP
44          61 02               48                    ret     1
                                49                  
                                50   
                                51   div10:
                                52   div10q:         EQU     RA
                                53   div10aNum:      EQU     RB
46          64 D0               54                    push    RBP
48          D2 DE               55                    move    RBP,RSP
                                56                  
4A          42 AD               57                    rload   RA,2[RBP]
4C          D2 1A               58                    move    r1,RA
4E          D2 2A               59                    move    r2,RA
50          A3 11               60                    srl     R1,1
52          A3 22               61                    srl     R2,2
54          5A 12               62                    add     RA,R1,R2
56          A3 A3               63                    srl     RA,3            # RA now may hold quotient
                                64   
58          D2 1A               65                    move    R1,RA
5A          A4 12               66                    sl      R1,2
5C          51 1A               67                    add     R1,R1,RA
5E          A4 11               68                    sl      R1,1            # quotient * 10
60          22 FF               69                    load    R2,0xFF
62          91 12               70                    xor     R1,R1,R2        # toggle all bits
64          42 BD               71                    rload   RB,2[RBP]       # argument
66          5B 11               72                    add     RB,R1,R1        # argument - (quotient * 10) == remainder
68          20 0A               73                    load    R0,10
6A          BB 76               74                    jmpEQ   RB=R0,div10return
6C          FB 76               75                    jmpLT   RB<R0,div10return
6E          21 01               76                    load    R1,1
70          5A A1               77                    add     RA,RA,R1
72          21 F6               78                    load    R1,-10
74          5B B1               79                    add     RB,RB,R1
                                80   div10return:   
                                81                  
76          D2 ED               82                    move    RSP,RBP
78          65 D0               83                    pop     RBP
7A          61 02               84                    ret     1
                                85                  
                                86                  
                                87   #def pBR( aNum ):
                                88   #    (quotient,remainder) = div10a( aNum )
                                89   #    if 10 <= aNum:
                                90   #        pBR( quotient )
                                91   
                                92   #    digitChar = chr( remainder | 0x30 )
                                93   #    print(digitChar, end="", flush=True)
                                94   # end pBR  
                                95   
                                96                   org    0xB0
                                97   pBR:
                                98   pBRquotient:    EQU     RA
                                99   pBRremainder:   EQU     RB
                               100   pBRaNum:        EQU     R3
B0          64 D0              101                    push    RBP
B2          D2 DE              102                    move    RBP,RSP
                               103                                
B4          42 3D              104                    rload   pBRaNum,2[RBP]
                               105                   # check for 0x80 which could be passed in
B6          20 80              106                    load    R0,0x80
B8          B3 BC              107                    jmpEQ   pBRaNum=R0,pBRnegative
BA          B0 C2              108                    jmp     pBRnormal
                               109   pBRnegative:
BC          2A 0C              110                    load    RA,12       # 128/10
BE          2B 08              111                    load    RB,8            # 128 % 10
C0          B0 CA              112                    jmp     pBRcall
                               113   
C2          64 30              114    pBRnormal:      push    pBRaNum
C4          60 46              115                    call    div10
                               116                   # test for recursion
C6          20 0A              117                    load    R0,10
C8          F3 D2              118                    jmpLT   pBRaNum<R0,pBRdisplay
CA          64 B0              119    pBRcall:        push    pBRremainder    #save it so we have it when we return
CC          64 A0              120                    push    pBRquotient
CE          60 B0              121                    call    pBR
D0          65 B0              122                    pop     pBRremainder    #recover remainder
D2          22 30              123    pBRdisplay:     load    R2,0x30
D4          7F B2              124                    or      RF,pBRremainder,R2
                               125                  
                               126   pBRreturn:                    
D6          D2 ED              127                    move    RSP,RBP
D8          65 D0              128                    pop     RBP
DA          61 02              129                    ret     1
DC          80 C1 E1 F1 F8     130    Numbers:        db      -128, -63, -31,-15, -8, 0, 3, 63, 64, 65, 0x7F
            00 03 3F 40 41            
            7F                        
E7          0B                 131    Length:         db      11


***************** WALL Cross-Reference Listing *******************
Created date: 05/05/2016 06:22:49 PM


         Cross-Reference Listing Description
Labels: The label name that appears in the source program.
Mem_Loc: Memory location of a label in the memory. If the value
         starts with 'R', it represents a register.
Def_Line: Defined line number of a label in the source code.
Ref_line: Referenced line number(s) of a label in the source code.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Labels           Mem_Loc     Def_Line     Ref_line
